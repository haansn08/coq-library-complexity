\documentclass[a4paper,UKenglish,cleveref, autoref]{lipics-v2019}
\usepackage{proof}
\usepackage{gensymb}
%This is a template for producing LIPIcs articles. 
%See lipics-manual.pdf for further information.
%for A4 paper format use option "a4paper", for US-letter use option "letterpaper"
%for british hyphenation rules use option "UKenglish", for american hyphenation rules use option "USenglish"
%for section-numbered lemmas etc., use "numberwithinsect"
%for enabling cleveref support, use "cleveref"
%for enabling cleveref support, use "autoref"


%\graphicspath{{./graphics/}}%helpful if your graphic files are in another directory

\bibliographystyle{plainurl}% the mandatory bibstyle

\title{A formalised polynomial-time reduction from \emph{3SAT} to \emph{Clique}} %TODO Please add

\titlerunning{Dummy short title}%optional, please use if title is longer than one line

\author{Lennard Gäher}{Saarland University, Germany}{s8legaeh@stud.uni-saarland.de}{}{}%TODO mandatory, please use full name; only 1 author per \author macro; first two parameters are mandatory, other parameters can be empty. Please provide at least the name of the affiliation and the country. The full address is optional

\authorrunning{L. Gäher}%TODO mandatory. First: Use abbreviated first/middle names. Second (only in severe cases): Use first author plus 'et al.'

\Copyright{Lennard Gäher}%TODO mandatory, please use full first names. LIPIcs license is "CC-BY";  http://creativecommons.org/licenses/by/3.0/

%\ccsdesc[100]{General and reference~General literature}
%\ccsdesc[100]{General and reference}%TODO mandatory: Please choose ACM 2012 classifications from https://dl.acm.org/ccs/ccs_flat.cfm 

%\keywords{Dummy keyword}%TODO mandatory; please add comma-separated list of keywords

%\category{}%optional, e.g. invited paper

\relatedversion{}%optional, e.g. full version hosted on arXiv, HAL, or other respository/website
%\relatedversion{A full version of the paper is available at \url{...}.}

\supplement{}%optional, e.g. related research data, source code, ... hosted on a repository like zenodo, figshare, GitHub, ...

%\funding{(Optional) general funding statement \dots}%optional, to capture a funding statement, which applies to all authors. Please enter author specific funding statements as fifth argument of the \author macro.


\nolinenumbers %uncomment to disable line numbering

\hideLIPIcs  %uncomment to remove references to LIPIcs series (logo, DOI, ...), e.g. when preparing a pre-final version to be uploaded to arXiv or another public repository

%Editor-only macros:: begin (do not touch as author)%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\EventEditors{John Q. Open and Joan R. Access}
\EventNoEds{2}
\EventLongTitle{42nd Conference on Very Important Topics (CVIT 2016)}
\EventShortTitle{CVIT 2016}
\EventAcronym{CVIT}
\EventYear{2016}
\EventDate{December 24--27, 2016}
\EventLocation{Little Whinging, United Kingdom}
\EventLogo{}
\SeriesVolume{42}
\ArticleNo{23}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\include{macros}

\begin{document}

\maketitle

%TODO mandatory: add short abstract of the document
\begin{abstract}
  We present a formalisation of the well-known problems \textbf{SAT} and \textbf{Clique} from computational complexity theory. From there, a polynomial-time reduction from \textbf{3SAT}, a variant of \textbf{SAT} where every clause has exactyly three literals, is developed and verified. 
  All the results are constructively formalised in the proof assistant Coq, including the polynomial running time bounds. The machine model we use is the weak call-by-value lambda calculus. 
\end{abstract}

\section{Introduction}
Since Karp presented his 21 \emph{NP-complete} problems in 1972, the concept of NP-completeness has proved very fruitful in computational complexity theory. Many of his original reductions are nowadays taught in undergraduate courses on theoretical computer science. 
While the ideas these reductions rely on are very simple conceptually, the proofs of correctness are done with a lot of handwaving, relying on the reader's intuition. The reasons for this are diverse: Turing machines, the standard computatinal model in the theory of NP-completeness, are very low-level and non-compositional, making formal arguments about their behaviour quite painful. Moreover, formal running time analyses are often deemed unnecessary, since the involved machines only need to run in polynomial time -- which can usually be readily believed.

Nevertheless, a formal treatment of the theory of NP-completeness is desirable: Verifying these proofs that have been taught for decades might yield new insights into invariants which are tacitly assumed.

In this memo, we provide a formalisation of the \textbf{SAT} and \textbf{Clique} problems, prove that they are in \emph{NP} and provide a formalisation of a well-known reduction from \textbf{3SAT} to \textbf{Clique}. We use a weak call-by-value lambda calculus called L introduced by Forster and Smolka in~\cite{ForsterSmolka:2017:L-Computability} as the model of computation. L has been proved to be a reasonable computational model by Forster et al.\ in~\cite{ForsterKunzeRoth:2019:wcbv-Reasonable}, in the sense that L and Turing machines can simulate each other with a polynomial overhead in time and a constant overhead in space. 
While the lambda-calculus is higher-level than Turing machines, directly programming in L is still unpleasant. Forster and Kunze have provided a framework for the certifying extraction of Coq terms to L terms, which also allows the user to instantiate time bounds during the extraction process~\cite{ForsterKunze:2019:Certifying-extraction}. Thus we can formalise problems and reductions in Coq and later extract these definitions to L, proving running time bounds in the process.

\section{SAT}
\newcommand{\var}{\textsf{var}}
\newcommand{\literal}{\textsf{literal}}
\newcommand{\clause}{\textsf{clause}}
\newcommand{\cnf}{\textsf{cnf}}
\newcommand{\assgn}{\textsf{assgn}}

\newcommand*{\eval}[2]{\mathcal{E}~#1~#2~}

When formalising computational problems, one has to strike a balance regarding abstraction and technical sophistication: While reasoning about correctness in Coq can be done in a much more elegant way when using abstract formalisations and inductive predicates instead of computational functions, members of $\mathbb{P}$, the universe of propositions, cannot be extracted to L. Running time analyses get easier, too, when employing simple formalisations. 

We therefore define most properties using inductive predicates and accompany them with boolean deciders if necessary, while all datatypes used for the problem definitions are kept as simple as possible.

\subsection{Conjunctive Normal Forms}
Following this line of thought, we define a simple list-based representation of conjunctive normal forms (CNFs):
\begin{align*}
  x : \var := \nat &&
  L : \literal := \bool \times \var &&
  C : \clause := \listsof \literal &&
  N : \cnf := \listsof \clause && 
\end{align*}
A literal is represented by a pair of a boolean denoting its sign and its variable. 
Assignments are lists of booleans: $a : \assgn := \listsof \bool$. The list $[\btrue, \bfalse, \btrue]$, for instance, denotes the assignment $\{x_0 \mapsto 1, x_1 \mapsto 0, x_2 \mapsto 1\}$. 
  
The evaluation of CNFs is defined via boolean functions recursively defined on the structure of the lists:
\begin{align*}
  ([]).0 := \None && (x :: xs).0 := \Some{x} && ([]).(S n) := \None && (x :: xs).(S n) := xs.n
\end{align*}
\vspace{-2em}
\begin{align*}
  \textsf{foldrO} &: (B \rightarrow A \rightarrow \opt{(A)})  \rightarrow \opt{(A)} \rightarrow \listsofb B \rightarrow \opt{(A)}\\ 
  \textsf{foldrO}~f~acc~[] &:= acc\\
  \textsf{foldrO}~f~acc~(x::xs) &:= \match \textsf{foldrO}~f~acc~xs~\withl \Some acc \Rightarrow (f~x~acc) \withm \None \Rightarrow \None \withr
\end{align*}
\vspace{-2em}
\begin{align*}
  \eval{a}{L} &:= \llet (s, n) := L~\lin \match a.n \withl \Some {value} \Rightarrow \Some {(\eqb{s}{value})} \withm \None \Rightarrow \None \withr \\
  \eval{a}{C} &:= \textsf{foldrO}~(\lambda~L~acc.~ \match \eval{a}{L} \withl \Some{v} \Rightarrow \Some{(acc~\orb~v)} \withm \None \Rightarrow \None\withr)~(\Some{\bfalse})~C \\
  \eval{a}{N} &:= \textsf{foldrO}~(\lambda~C~acc.~ \match \eval{a}{C} \withl\Some{v} \Rightarrow \Some{(acc~\andb~v)} \withm \None \Rightarrow \None\withr)~(\Some{\btrue})~N
\end{align*}

The function $xs.n$ yields the $n$-th element of $xs$, wrapped in the option type $\opt{}$, or $\None$ if the subscript is invalid and is used to lookup values of assignments. \textsf{foldrO} is a variant of the known fold-right function, but the aggregation function returns an element of $\opt{(A)}$. The folding only continues as long as the aggregation result is not $\None$. 
Using \textsf{foldrO}, the definition of the evaluation functions $\mathcal{E}$ is straightforward. The presence of option values is due to our choice that an assignment only has finite support, which we find more expressive than using default values. 
We use $\mathcal{E}$ to refer to evaluation of both literals, clauses and CNFs, but from the context it will always be clear which of the functions we mean.

Next we introduce the notion of boundedness of CNFs: a CNF $N$ is bounded by $k$, written $N \prec k$, if all variables occuring in $N$ are strictly smaller than $k$. We need the same notion for clauses and again use the same notation to refer to boundedness of clauses and CNFs. This is formalised using inductive predicates:
\begin{align*}
  \infer{[] \prec k}{} && \infer{((s, n) :: C) \prec k}{n < k \quad C \prec k} && \infer{[] \prec k}{} && \infer{C :: N \prec k}{C \prec k && N \prec k}
\end{align*}

\begin{proposition}\label{prop:varboundmono}\leavevmode
  \begin{enumerate}
    \item $k \le k' \rightarrow C \prec k \rightarrow C \prec k'$
    \item $k \le k' \rightarrow N \prec k \rightarrow C \prec k'$
  \end{enumerate}
\end{proposition}

\begin{proposition}\label{prop:evalbounded}
  If the CNF is bounded by the length $\length{a}$ of the assignment, evaluation will yield a result.
  \begin{enumerate}
    \item $v < k \rightarrow \length{a} \ge k \rightarrow \exists~r. \eval{a}{(s, v)} = \Some{r}$
    \item $C \prec k \rightarrow \length{a} \ge k \rightarrow \exists~r. \eval{a}{C} = \Some{r}$
    \item $N \prec k \rightarrow \length{a} \ge k \rightarrow \exists~r. \eval{a}{N} = \Some{r}$
  \end{enumerate}
\end{proposition}
\begin{proof}
  1.\ is proved using standard facts on $xs.n$. 2.\ and 3.\ are proved by induction on $C \prec k$ and $N \prec k$, respectively. In the inductive step of 2., we need 1., while we need 2.\ in the inductive step of 3.
\end{proof}
  
The converse statements of Proposition~\ref{prop:evalbounded} also hold.

\begin{proposition}\label{prop:boundedeval}
  If evaluation succeeds for an assignment $a$, the CNF is bounded by $\length{a}$. 
  \begin{enumerate}
    \item $(\exists~r. \eval{a}{(s, v)} = \Some{r}) \rightarrow v < \length{a}$
    \item $(\exists~r. \eval{a}{C} = \Some{r}) \rightarrow C \prec \length{a}$
    \item $(\exists~r. \eval{a}{N} = \Some{r}) \rightarrow N \prec \length{a}$
  \end{enumerate}
\end{proposition}

Apart from the inductive predicate $\prec$, we will also need a computable notion of boundedness which can be extracted to L. We use functions $\textsf{maxClause}$ and $\textsf{maxCnf}$ that compute the maximal variable which is used in a clause or CNF, respectively: 
\begin{align*}
  \textsf{maxClause}~C &:= \textsf{foldr}~(\lambda~(\_, n)~acc.~\max acc~n)~0~C \\
  \textsf{maxCnf}~N &:= \textsf{foldr}~(\lambda~C~acc.~\max acc~(\textsf{maxClause}~C))~0~N
\end{align*}

\begin{proposition}\label{prop:maxvarbounded}
  A CNF is bounded by the successor of the maximal variable.
  \begin{enumerate}
    \item $C \prec (\natS{\textsf{maxClause}~C})$
    \item $N \prec (\natS{\textsf{maxCnf}~N})$
  \end{enumerate}
\end{proposition}
\begin{proof}
  \begin{enumerate}
    \item The statement is shown using induction on $C$. In the inductive step, the inductive definition of $\prec$ leaves us with two proof obligations. For the second obligation $C \prec (\natS{\textsf{maxClause}(L::C)})$ for some literal $L$, we need the monoticity given by Proposition~\ref{prop:varboundmono}. 
    \item Similar to 1.
  \end{enumerate}
\end{proof}

We proceed with results on the evaluation functions.

\begin{lemma}\label{prop:evalstepinv}
  One evaluation step can be characterised as follows:
  \begin{enumerate}
    \item $\eval{a}{(L::C)} = \Some{b} \leftrightarrow \exists~b_1,b_2. \eval{a}{C} = \Some{b_1} \land \eval{a}{L} = \Some{b_2} \land b = b_1~\orb~b_2$
    \item $\eval{a}{(C::N)} = \Some{b} \leftrightarrow \exists~b_1,b_2. \eval{a}{N} = \Some{b_1} \land \eval{a}{C} = \Some{b_2} \land b = b_1~\andb~b_2$
  \end{enumerate}
\end{lemma}
\begin{proof}
  Using induction on $C$ and $N$, respectively. A few case analyses are needed, but otherwise the proof is standard.
\end{proof}

We can now derive a helpful equivalent characterisation of satisfaction of clauses and CNFs:

\begin{lemma}\label{prop:evalclauseiff}\leavevmode
  \begin{enumerate}
    \item
      $\eval{a}{C} = \Some{\btrue} \leftrightarrow (\exists~L \in C. \eval{a}{L} = \Some{\btrue}) \land C \prec \length{a}$
    \item 
      $\eval{a}{N} = \Some{\btrue} \leftrightarrow (\forall~C \in N. \eval{a}{C} = \Some{\btrue}) \land N \prec \length{a}$
  \end{enumerate}
\end{lemma}
\begin{proof}
  \begin{enumerate}
    \item By induction on $C$. The base case is trivial. In the direction from left to right in the inductive step, the statement $L::C \prec \length{a}$ follows directly from Proposition~\ref{prop:boundedeval}. For the other part of the conjunction, we apply Lemma~\ref{prop:evalstepinv}.
      For the direction from right to left, we need Proposition~\ref{prop:evalbounded} and a few case analyses.    
    \item By induction on $N$. The proof is simpler than the one for 1. In the inductive step, we need Lemma~\ref{prop:evalstepinv}.
  \end{enumerate}
\end{proof}

\subsection{Satisfiability}
We now define \textbf{SAT} as the following problem:
\begin{definition}
  Given a CNF $N$, \textbf{SAT} is the problem of determining whether there exists a satisfying assignment $a$:
  \[\textbf{SAT}~N := \exists~a. \eval{a}{N} = \Some{\btrue} \]
\end{definition}

In the remainder of this section, we show that \textbf{SAT} is in NP. We use the well-known definition of NP using polynomial-time verifiers, since this saves us from introducing nondeterminism to L. 
The verifier gets a problem instance and a certificate and has to check whether the certificate is a valid proof of the instance being an inhabitant of the problem at hand. There should be valid certificates exactly for the positive instances. We require that a verifier only accepts certificates having an encoding size polynomial in the encoding size of the instance\footnote{An alternative definition not posing this restriction, but instead requiring that there exists a certificate of polynomial size exactly for the positive instances would also work, but make proofs more complicated.}.

Using the functions defined above, it is straightforward to define a verifier for \textbf{SAT}:
\begin{align*}
  \textsf{Ver}_{\textbf{SAT}}~N~a := \eval{a}{C} = \Some{\btrue} \land \length{a} \le \natS{\textsf{maxCnf}~N} 
\end{align*}
Note that this is again a propositional definition. A boolean decider, which can then be extracted to L, can be derived in a straightforward way, though. The second condition captures the requirement of polynomial certificates: Valid certificates are only as long as they need to be. Nevertheless, it isn't straightforward to see that the requirement is actually fulfilled: It only works because the Scott encoding of natural numbers which we use is unary in nature. Since the encoding size of Booleans is constant, the encoding size of a minimal satisfying assignment is thus linear in the encoding size of the maximal variable used, which is part of the encoding of the CNF.

In order to derive that \textbf{SAT} is in NP, we need to show that:
\begin{enumerate}
  \item $\textbf{SAT}~N \leftrightarrow \exists~a. \textsf{Ver}_{\textbf{SAT}}~N~a$,
  \item the boolean version of $\textsf{Ver}_\textbf{SAT}$ runs in polynomial time in the encoding size of its two inputs,
  \item $\textsf{Ver}_\textbf{SAT}$ only accepts certificates whose encoding size is polynomial in the encoding size of $N$.
\end{enumerate}

Since 2.\ and 3.\ are quite technical to prove, we only go into step 1.\ in detail. Essentially, we need to show that if there exists a certificate, i.e.\ a satisfying assignment, then there also exists a short one. This short assignment can be obtained by only taking a prefix of the assignment. The standard $\textsf{take} : \listsof~A \rightarrow \nat \rightarrow \listsof~A$ function is used.

\begin{lemma}\label{prop:boundedcapassgn}\leavevmode
  \begin{enumerate}
    \item $n < k \rightarrow \eval{a}{(s, n)} = \Some{v} \rightarrow \eval{(\normalfont\textsf{take}~a~k)}{(s, n)} = \Some{v}$
    \item $C \prec k \rightarrow \eval{a}{C} = \Some{v} \rightarrow \eval{(\normalfont\textsf{take}~a~k)}{C} = \Some{v}$
    \item $N \prec k \rightarrow \eval{a}{N} = \Some{v} \rightarrow \eval{(\normalfont\textsf{take}~a~k)}{N} = \Some{v}$
  \end{enumerate}
\end{lemma}
\begin{proof}
  1.\ follows from $n < k \rightarrow l.n = \Some{v} \rightarrow (\textsf{take}~l~k).n = \Some{v}$, which is proved using standard facts on \textsf{take} and $l.n$.
  2.\ and 3.\ follow by induction on $C$ and $N$, respectively.
\end{proof}

\subsection{$k$-Satisfiability}
We introduce the notion of $k$-CNFs using an inductive predicate.

\begin{align*}
  \infer{\textsf{kCNF}~k~[]}{k > 0} && \infer{\textsf{kCNF}~k~(C::N)}{\length{C} = k \quad \textsf{kCNF}~k~N}
\end{align*}

Thus, the representation of $k$-CNFs does not differ from the representation of unconstrained CNFs. 

\begin{proposition}\label{prop:kCNFexp}
  $\textsf{kCNF}~k~N \leftrightarrow k > 0 \land \forall C \in N. k = \length{C}$
\end{proposition}

The corresponding problem is $k$-\textbf{SAT}:
\begin{definition}
  For every fixed $k$, $k$-\textbf{SAT} is the problem of determining whether there exists a satisfying assignment $a$ for a $k$-CNF $N$: 
  \[$k$-\textbf{SAT}~N := \textsf{kCNF}~k~N \land \exists~a.\eval{a}{N} = \Some{\btrue} \]
\end{definition}

TODO: maybe show the reduction to SAT.

\section{Clique}
In this section, we formalise the \textbf{Clique} problem. 

\subsection{Graphs}
\newcommand{\lnode}{\textsf{node}}
\newcommand{\ledge}{\textsf{edge}}
\newcommand{\lgraph}{\textsf{graph}}
We start with a formalisation of undirected graphs which can be extracted to L. Again, we strive to keep the representation as simple as possible in order to admit a compact running time analysis, trading off expressivity. Thus we use a list-based representation.
\begin{align*}
  n,u,v : \lnode := \nat && e : \ledge := \lnode \times \lnode && g : \lgraph := \nat \times \listsof~\ledge 
\end{align*}

A graph is pair of a natural number giving the number of nodes and a list of edges. This definition is very weak and doesn't give any semantic guarantees. We correct for this lack by giving an inductive predicate defining well-formed graphs:
\begin{align*}
  \infer{\textsf{gwf}~(n,[])}{} && \infer{\textsf{gwf}~(n,(u, v) :: e)}{u < n \quad v < n \quad \textsf{gwf}~(n, e)}
\end{align*}

We give Boolean deciders for node and edge containment:
\begin{align*}
  \textsf{nodeIn}~g~n := \llet (max, \_) := g~\lin (\natS n) \overset{?}{\le} max\\
  \textsf{edgeIn}~g~u~v := \llet (\_, e) := g~\lin (u, v) \overset{?}{\in} e~\orb~(v, u) \overset{?}{\in} e
\end{align*}

While our definition of the type \textsf{edge} works with pairs, we are giving it the semantics of an undirected graph.

\subsection{Clique}
A $k$-clique is a duplicate-free list of $k$ nodes such that all pairwise-distinct nodes are connected.

\begin{align*}
  \infer{\textsf{isClique}~g~[]~0}{} && \infer{\textsf{isClique}~g~(n::cl)~(\natS k)}{n \notin cl \quad \textsf{nodeIn}~g~n = \btrue \quad (\forall n' \in cl. \textsf{edgeIn}~g~n~n' = \btrue) \quad \textsf{isClique}~g~cl~k}
\end{align*}

\begin{lemma}[Explicit characterisation]\label{prop:cliqueexpl}
  \begin{align*}
    \normalfont\textsf{isClique}~g~cl~k \leftrightarrow \length{cl} = k \land \normalfont\textsf{dupfree}~cl &\land (\forall n \in cl. \normalfont\textsf{nodeIn}~g~n = \btrue) \\
    &\land (\forall u,v \in cl. u \neq v \rightarrow \normalfont\textsf{edgeIn}~g~u~v = \btrue)
  \end{align*}
\end{lemma}
\begin{proof}
  The direction from left to right follows by an induction on the derivation of \textsf{isClique}. The other direction follows by an induction on $cl$.
\end{proof}

We can now define the \textbf{Clique} problem.

\begin{definition}
  Given a graph $g$ and a natural number $k > 0$, \textbf{Clique} is the problem of determining whether there is a set of nodes $cl$ such that $cl$ is a $k$-clique in $g$:
  \[\normalfont\textbf{Clique} (g, k) := \exists~cl. \normalfont\textsf{isClique}~g~cl~k \]
\end{definition}

A verifier can be derived mechanically, using the list of nodes as the certificate:
\[\textsf{Ver}_{\textbf{Clique}} ((g, k), cl) := \textsf{isClique}~g~cl~k \]
In contrast to the \textbf{SAT} verifier, we need not explcitly require that the certificate is short enough, since already \textsf{isClique} places a bound. At this point it is critical that the representation of graphs explicitly contains a bound on the indices of nodes.

It is straightforward to obtain a Boolean decider for the \textsf{isClique} predicate and thus a computable verifier.

\section{Reducing \textbf{3SAT} to \textbf{Clique}}
In this section, we finally reduce \textbf{3SAT} to \textbf{Clique}. The reduction is well-known; nevertheless, we give a short account of the intuition behind it. 

Given a \textbf{3SAT} instance $N$, we have to construct a graph $g$ and a number $k$ such that $g$ has a $k$-clique if, and only if, $N$ is satisfiable. First observe that an assignment satisfies $N$ iff for every clause $C \in N$, there is at least one literal $L \in C$ such that $\eval{a}{L} = \Some{\btrue}$ (this is a direct consequence of the two statements in Lemma~\ref{prop:evalclauseiff}). 
We therefore construct a graph with $3 \cdot \length{N}$ nodes, one for each literal: $n^0_0, n^0_1, n^0_2, n^1_0, \ldots, n^{\length{N}}_2$. Two nodes $n^i_j, n^k_l$ are connected via an edge iff $i \neq k$, i.e.\ the corresponding literals belong to distinct clauses, and the literals are not conflicting, meaning that there is an assignment that satisfies both literals simultaneously.
It is easy to believe (although not formally satisfying) that this construction does indeed satsisfy the desired equivalence. 

\begin{definition}[Conflicting literals]
  \[\normalfont\textsf{conflict}~(s_1, n_1)~(s_2, n_2) := s_1 \neq s_2 \land n_1 = n_2 \]
\end{definition}
\begin{proposition}\label{prop:conflictingassgn}
  \[n_1 < \length{a} \rightarrow n_2 < \length{a} \rightarrow (\normalfont\textsf{conflict}~(s_1, n_1)~(s_2, n_2) \leftrightarrow \eval{a}{(s_1, n_1)} \neq \eval{a}{(s_2, n_2)}) \]
\end{proposition}

In order to reason about the reduction, we have to somehow connect a CNF with the corresponding graph. Since there is a one-to-one correspondence between literals of the CNF and nodes of the graph, we require a bijection between nodes and literals. However, there can be several literals in one CNF that are syntactically identical but are at different positions in the list representation, meaning that we cannot simply use elements of \literal. Instead, we use pairs of indices describing the index of the clause and the index of the literal inside this clause.

\begin{definition}[Bijections of sets]
  Let two sets be given by $p : X \rightarrow \Prop$ and $q : Y \rightarrow \Prop$. Let $f : X \rightarrow Y$ and $g : Y \rightarrow X$.
  \[\normalfont\textsf{inverseOn}~p~q~f~g := (\forall x. p~x \rightarrow q(f~x) \land x = g(f~x)) \land (\forall y. q~y \rightarrow p(f~y) \land y = f(g~y)) \]
\end{definition}
\begin{definition}[Labellings of graphs]
  A labelling assigns each node of a graph a corresponding literal, and vice versa.
  \begin{align*}
  \textsf{labG} := \nat \rightarrow \nat \times \nat && \textsf{labG}^{-1} := \nat \times \nat \rightarrow \nat
  \end{align*}
  \begin{align*}
  \textsf{isLabelling}~N~(f : \textsf{labG})~(f^{-1} : \textsf{labG}^{-1}) := \textsf{inverseOn}~f~f^{-1}~ &(\lambda~v. v < 3 \cdot \length{N})\\
  ~&(\lambda~(c, l). c < \length{N} \land l < 3) 
\end{align*}
\end{definition}


First intuitive graphical overview of the reduction.

Then the relation-based approach, labelling, etc.

Present both directions of the relation-based equivalence, but leave out intermediate results that are too technical.

Finally the reduction function. 

\section{Typesetting instructions -- Summary}
\label{sec:typesetting-summary}

LIPIcs is a series of open access high-quality conference proceedings across all fields in informatics established in cooperation with Schloss Dagstuhl. 
In order to do justice to the high scientific quality of the conferences that publish their proceedings in the LIPIcs series, which is ensured by the thorough review process of the respective events, we believe that LIPIcs proceedings must have an attractive and consistent layout matching the standard of the series.
Moreover, the quality of the metadata, the typesetting and the layout must also meet the requirements of other external parties such as indexing service, DOI registry, funding agencies, among others. The guidelines contained in this document serve as the baseline for the authors, editors, and the publisher to create documents that meet as many different requirements as possible. 

Please comply with the following instructions when preparing your article for a LIPIcs proceedings volume. 
\paragraph*{Minimum requirements}

\begin{itemize}
\item Use pdflatex and an up-to-date \LaTeX{} system.
\item Use further \LaTeX{} packages and custom made macros carefully and only if required.
\item Use the provided sectioning macros: \verb+\section+, \verb+\subsection+, \verb+\subsubsection+, \linebreak \verb+\paragraph+, \verb+\paragraph*+, and \verb+\subparagraph*+.
\item Provide suitable graphics of at least 300dpi (preferably in PDF format).
\item Use BibTeX and keep the standard style (\verb+plainurl+) for the bibliography.
\item Please try to keep the warnings log as small as possible. Avoid overfull \verb+\hboxes+ and any kind of warnings/errors with the referenced BibTeX entries.
\item Use a spellchecker to correct typos.
\end{itemize}

\paragraph*{Mandatory metadata macros}
Please set the values of the metadata macros carefully since the information parsed from these macros will be passed to publication servers, catalogues and search engines.
Avoid placing macros inside the metadata macros. The following metadata macros/environments are mandatory:
\begin{itemize}
\item \verb+\title+ and, in case of long titles, \verb+\titlerunning+.
\item \verb+\author+, one for each author, even if two or more authors have the same affiliation.
\item \verb+\authorrunning+ and \verb+\Copyright+ (concatenated author names)\\
The \verb+\author+ macros and the \verb+\Copyright+ macro should contain full author names (especially with regard to the first name), while \verb+\authorrunning+ should contain abbreviated first names.
\item \verb+\ccsdesc+ (ACM classification, see \url{https://www.acm.org/publications/class-2012}).
\item \verb+\keywords+ (a comma-separated list of keywords).
\item \verb+\relatedversion+ (if there is a related version, typically the ``full version''); please make sure to provide a persistent URL, e.\,g., at arXiv.
\item \verb+\begin{abstract}...\end{abstract}+ .
\end{itemize}

\paragraph*{Please do not \ldots} %Do not override the \texttt{\seriesstyle}-defaults}
Generally speaking, please do not override the \texttt{lipics-v2019}-style defaults. To be more specific, a short checklist also used by Dagstuhl Publishing during the final typesetting is given below.
In case of \textbf{non-compliance} with these rules Dagstuhl Publishing will remove the corresponding parts of \LaTeX{} code and \textbf{replace it with the \texttt{lipics-v2019} defaults}. In serious cases, we may reject the LaTeX-source and expect the corresponding author to revise the relevant parts.
\begin{itemize}
\item Do not use a different main font. (For example, the \texttt{times} package is forbidden.)
\item Do not alter the spacing of the \texttt{lipics-v2019.cls} style file.
\item Do not use \verb+enumitem+ and \verb+paralist+. (The \texttt{enumerate} package is preloaded, so you can use
 \verb+\begin{enumerate}[(a)]+ or the like.)
\item Do not use ``self-made'' sectioning commands (e.\,g., \verb+\noindent{\bf My+ \verb+Paragraph}+).
\item Do not hide large text blocks using comments or \verb+\iffalse+ $\ldots$ \verb+\fi+ constructions. 
\item Do not use conditional structures to include/exclude content. Instead, please provide only the content that should be published -- in one file -- and nothing else.
\item Do not wrap figures and tables with text. In particular, the package \texttt{wrapfig} is not supported.
\item Do not change the bibliography style. In particular, do not use author-year citations. (The
\texttt{natbib} package is not supported.)
\end{itemize}

\enlargethispage{\baselineskip}

This is only a summary containing the most relevant details. Please read the complete document ``LIPIcs: Instructions for Authors and the \texttt{lipics-v2019} Class'' for all details and don't hesitate to contact Dagstuhl Publishing (\url{mailto:publishing@dagstuhl.de}) in case of questions or comments:
\href{http://drops.dagstuhl.de/styles/lipics-v2019/lipics-v2019-authors/lipics-v2019-authors-guidelines.pdf}{\texttt{http://drops.dagstuhl.de/styles/lipics-v2019/\newline lipics-v2019-authors/lipics-v2019-authors-guidelines.pdf}}

\section{Lorem ipsum dolor sit amet}

Lorem ipsum dolor sit amet, consectetur adipiscing elit \cite{DBLP:journals/cacm/Knuth74}. Praesent convallis orci arcu, eu mollis dolor. Aliquam eleifend suscipit lacinia. Maecenas quam mi, porta ut lacinia sed, convallis ac dui. Lorem ipsum dolor sit amet, consectetur adipiscing elit. Suspendisse potenti. Donec eget odio et magna ullamcorper vehicula ut vitae libero. Maecenas lectus nulla, auctor nec varius ac, ultricies et turpis. Pellentesque id ante erat. In hac habitasse platea dictumst. Curabitur a scelerisque odio. Pellentesque elit risus, posuere quis elementum at, pellentesque ut diam. Quisque aliquam libero id mi imperdiet quis convallis turpis eleifend. 

\begin{lemma}[Lorem ipsum]
\label{lemma:lorem}
Vestibulum sodales dolor et dui cursus iaculis. Nullam ullamcorper purus vel turpis lobortis eu tempus lorem semper. Proin facilisis gravida rutrum. Etiam sed sollicitudin lorem. Proin pellentesque risus at elit hendrerit pharetra. Integer at turpis varius libero rhoncus fermentum vitae vitae metus.
\end{lemma}

\begin{proof}
Cras purus lorem, pulvinar et fermentum sagittis, suscipit quis magna.

\begin{claim}
content...
\end{claim}
\begin{claimproof}
content...
\end{claimproof}

\end{proof}

\begin{corollary}[Curabitur pulvinar, \cite{DBLP:books/mk/GrayR93}]
\label{lemma:curabitur}
Nam liber tempor cum soluta nobis eleifend option congue nihil imperdiet doming id quod mazim placerat facer possim assum. Lorem ipsum dolor sit amet, consectetuer adipiscing elit, sed diam nonummy nibh euismod tincidunt ut laoreet dolore magna aliquam erat volutpat.
\end{corollary}

\begin{proposition}\label{prop1}
This is a proposition
\end{proposition}

\autoref{prop1} and \cref{prop1} \ldots

\subsection{Curabitur dictum felis id sapien}

Curabitur dictum \cref{lemma:curabitur} felis id sapien \autoref{lemma:curabitur} mollis ut venenatis tortor feugiat. Curabitur sed velit diam. Integer aliquam, nunc ac egestas lacinia, nibh est vehicula nibh, ac auctor velit tellus non arcu. Vestibulum lacinia ipsum vitae nisi ultrices eget gravida turpis laoreet. Duis rutrum dapibus ornare. Nulla vehicula vulputate iaculis. Proin a consequat neque. Donec ut rutrum urna. Morbi scelerisque turpis sed elit sagittis eu scelerisque quam condimentum. Pellentesque habitant morbi tristique senectus et netus et malesuada fames ac turpis egestas. Aenean nec faucibus leo. Cras ut nisl odio, non tincidunt lorem. Integer purus ligula, venenatis et convallis lacinia, scelerisque at erat. Fusce risus libero, convallis at fermentum in, dignissim sed sem. Ut dapibus orci vitae nisl viverra nec adipiscing tortor condimentum \cite{DBLP:journals/cacm/Dijkstra68a}. Donec non suscipit lorem. Nam sit amet enim vitae nisl accumsan pretium. 

\begin{lstlisting}[caption={Useless code},label=list:8-6,captionpos=t,float,abovecaptionskip=-\medskipamount]
for i:=maxint to 0 do 
begin 
    j:=square(root(i));
end;
\end{lstlisting}

\subsection{Proin ac fermentum augue}

Proin ac fermentum augue. Nullam bibendum enim sollicitudin tellus egestas lacinia euismod orci mollis. Nulla facilisi. Vivamus volutpat venenatis sapien, vitae feugiat arcu fringilla ac. Mauris sapien tortor, sagittis eget auctor at, vulputate pharetra magna. Sed congue, dui nec vulputate convallis, sem nunc adipiscing dui, vel venenatis mauris sem in dui. Praesent a pretium quam. Mauris non mauris sit amet eros rutrum aliquam id ut sapien. Nulla aliquet fringilla sagittis. Pellentesque eu metus posuere nunc tincidunt dignissim in tempor dolor. Nulla cursus aliquet enim. Cras sapien risus, accumsan eu cursus ut, commodo vel velit. Praesent aliquet consectetur ligula, vitae iaculis ligula interdum vel. Integer faucibus faucibus felis. 

\begin{itemize}
\item Ut vitae diam augue. 
\item Integer lacus ante, pellentesque sed sollicitudin et, pulvinar adipiscing sem. 
\item Maecenas facilisis, leo quis tincidunt egestas, magna ipsum condimentum orci, vitae facilisis nibh turpis et elit. 
\end{itemize}

\begin{remark}
content...
\end{remark}

\section{Pellentesque quis tortor}

Nec urna malesuada sollicitudin. Nulla facilisi. Vivamus aliquam tempus ligula eget ornare. Praesent eget magna ut turpis mattis cursus. Aliquam vel condimentum orci. Nunc congue, libero in gravida convallis \cite{DBLP:conf/focs/HopcroftPV75}, orci nibh sodales quam, id egestas felis mi nec nisi. Suspendisse tincidunt, est ac vestibulum posuere, justo odio bibendum urna, rutrum bibendum dolor sem nec tellus. 

\begin{lemma} [Quisque blandit tempus nunc]
Sed interdum nisl pretium non. Mauris sodales consequat risus vel consectetur. Aliquam erat volutpat. Nunc sed sapien ligula. Proin faucibus sapien luctus nisl feugiat convallis faucibus elit cursus. Nunc vestibulum nunc ac massa pretium pharetra. Nulla facilisis turpis id augue venenatis blandit. Cum sociis natoque penatibus et magnis dis parturient montes, nascetur ridiculus mus.
\end{lemma}

Fusce eu leo nisi. Cras eget orci neque, eleifend dapibus felis. Duis et leo dui. Nam vulputate, velit et laoreet porttitor, quam arcu facilisis dui, sed malesuada risus massa sit amet neque.

\appendix
\section{Morbi eros magna}

Morbi eros magna, vestibulum non posuere non, porta eu quam. Maecenas vitae orci risus, eget imperdiet mauris. Donec massa mauris, pellentesque vel lobortis eu, molestie ac turpis. Sed condimentum convallis dolor, a dignissim est ultrices eu. Donec consectetur volutpat eros, et ornare dui ultricies id. Vivamus eu augue eget dolor euismod ultrices et sit amet nisi. Vivamus malesuada leo ac leo ullamcorper tempor. Donec justo mi, tempor vitae aliquet non, faucibus eu lacus. Donec dictum gravida neque, non porta turpis imperdiet eget. Curabitur quis euismod ligula. 


%%
%% Bibliography
%%

%% Please use bibtex, 

\bibliography{memo}

\appendix

\section{Styles of lists, enumerations, and descriptions}\label{sec:itemStyles}

List of different predefined enumeration styles:

\begin{itemize}
\item \verb|\begin{itemize}...\end{itemize}|
\item \dots
\item \dots
%\item \dots
\end{itemize}

\begin{enumerate}
\item \verb|\begin{enumerate}...\end{enumerate}|
\item \dots
\item \dots
%\item \dots
\end{enumerate}

\begin{alphaenumerate}
\item \verb|\begin{alphaenumerate}...\end{alphaenumerate}|
\item \dots
\item \dots
%\item \dots
\end{alphaenumerate}

\begin{romanenumerate}
\item \verb|\begin{romanenumerate}...\end{romanenumerate}|
\item \dots
\item \dots
%\item \dots
\end{romanenumerate}

\begin{bracketenumerate}
\item \verb|\begin{bracketenumerate}...\end{bracketenumerate}|
\item \dots
\item \dots
%\item \dots
\end{bracketenumerate}

\begin{description}
\item[Description 1] \verb|\begin{description} \item[Description 1]  ...\end{description}|
\item[Description 2] Fusce eu leo nisi. Cras eget orci neque, eleifend dapibus felis. Duis et leo dui. Nam vulputate, velit et laoreet porttitor, quam arcu facilisis dui, sed malesuada risus massa sit amet neque.
\item[Description 3]  \dots
%\item \dots
\end{description}

\section{Theorem-like environments}\label{sec:theorem-environments}

List of different predefined enumeration styles:

\begin{theorem}\label{testenv-theorem}
Fusce eu leo nisi. Cras eget orci neque, eleifend dapibus felis. Duis et leo dui. Nam vulputate, velit et laoreet porttitor, quam arcu facilisis dui, sed malesuada risus massa sit amet neque.
\end{theorem}

\begin{lemma}\label{testenv-lemma}
Fusce eu leo nisi. Cras eget orci neque, eleifend dapibus felis. Duis et leo dui. Nam vulputate, velit et laoreet porttitor, quam arcu facilisis dui, sed malesuada risus massa sit amet neque.
\end{lemma}

\begin{corollary}\label{testenv-corollary}
Fusce eu leo nisi. Cras eget orci neque, eleifend dapibus felis. Duis et leo dui. Nam vulputate, velit et laoreet porttitor, quam arcu facilisis dui, sed malesuada risus massa sit amet neque.
\end{corollary}

\begin{proposition}\label{testenv-proposition}
Fusce eu leo nisi. Cras eget orci neque, eleifend dapibus felis. Duis et leo dui. Nam vulputate, velit et laoreet porttitor, quam arcu facilisis dui, sed malesuada risus massa sit amet neque.
\end{proposition}

\begin{exercise}\label{testenv-exercise}
Fusce eu leo nisi. Cras eget orci neque, eleifend dapibus felis. Duis et leo dui. Nam vulputate, velit et laoreet porttitor, quam arcu facilisis dui, sed malesuada risus massa sit amet neque.
\end{exercise}

\begin{definition}\label{testenv-definition}
Fusce eu leo nisi. Cras eget orci neque, eleifend dapibus felis. Duis et leo dui. Nam vulputate, velit et laoreet porttitor, quam arcu facilisis dui, sed malesuada risus massa sit amet neque.
\end{definition}

\begin{example}\label{testenv-example}
Fusce eu leo nisi. Cras eget orci neque, eleifend dapibus felis. Duis et leo dui. Nam vulputate, velit et laoreet porttitor, quam arcu facilisis dui, sed malesuada risus massa sit amet neque.
\end{example}

\begin{note}\label{testenv-note}
Fusce eu leo nisi. Cras eget orci neque, eleifend dapibus felis. Duis et leo dui. Nam vulputate, velit et laoreet porttitor, quam arcu facilisis dui, sed malesuada risus massa sit amet neque.
\end{note}

\begin{note*}
Fusce eu leo nisi. Cras eget orci neque, eleifend dapibus felis. Duis et leo dui. Nam vulputate, velit et laoreet porttitor, quam arcu facilisis dui, sed malesuada risus massa sit amet neque.
\end{note*}

\begin{remark}\label{testenv-remark}
Fusce eu leo nisi. Cras eget orci neque, eleifend dapibus felis. Duis et leo dui. Nam vulputate, velit et laoreet porttitor, quam arcu facilisis dui, sed malesuada risus massa sit amet neque.
\end{remark}

\begin{remark*}
Fusce eu leo nisi. Cras eget orci neque, eleifend dapibus felis. Duis et leo dui. Nam vulputate, velit et laoreet porttitor, quam arcu facilisis dui, sed malesuada risus massa sit amet neque.
\end{remark*}

\begin{claim}\label{testenv-claim}
Fusce eu leo nisi. Cras eget orci neque, eleifend dapibus felis. Duis et leo dui. Nam vulputate, velit et laoreet porttitor, quam arcu facilisis dui, sed malesuada risus massa sit amet neque.
\end{claim}

\begin{claim*}\label{testenv-claim2}
Fusce eu leo nisi. Cras eget orci neque, eleifend dapibus felis. Duis et leo dui. Nam vulputate, velit et laoreet porttitor, quam arcu facilisis dui, sed malesuada risus massa sit amet neque.
\end{claim*}

\begin{proof}
Fusce eu leo nisi. Cras eget orci neque, eleifend dapibus felis. Duis et leo dui. Nam vulputate, velit et laoreet porttitor, quam arcu facilisis dui, sed malesuada risus massa sit amet neque.
\end{proof}

\begin{claimproof}
Fusce eu leo nisi. Cras eget orci neque, eleifend dapibus felis. Duis et leo dui. Nam vulputate, velit et laoreet porttitor, quam arcu facilisis dui, sed malesuada risus massa sit amet neque.
\end{claimproof}

\end{document}
